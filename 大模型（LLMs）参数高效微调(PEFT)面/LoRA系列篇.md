# LoRA 系列篇
好文：图解https://www.53ai.com/news/finetuning/2024101307549.html

lora：<img width="968" alt="image" src="https://github.com/user-attachments/assets/55012f7b-9e3b-4a9e-8c24-c0c75e76a5ad" />
lora-fa：<img width="1152" alt="image" src="https://github.com/user-attachments/assets/e75d7e86-cd2d-4d92-b2a9-95216b6bda2f" />
vera：<img width="869" alt="image" src="https://github.com/user-attachments/assets/1035ac44-5db6-4f87-8803-d2b5848ac77b" />
delta-lora：<img width="974" alt="image" src="https://github.com/user-attachments/assets/5d1f5ab7-274b-443e-ab2b-b1b82a5100c2" />
lora+：<img width="883" alt="image" src="https://github.com/user-attachments/assets/424a5a88-711d-4a03-9a98-76d870b3b443" />
lora-drop：<img width="1256" alt="image" src="https://github.com/user-attachments/assets/112f33f9-4288-4ed9-acea-1c6becfe5e1d" />


- 一、LoRA篇
    - 1.1 什么是 LoRA？
        
        <aside>
        💡 **什么是low-rank adaptation of large language models？**
        
        "low-rank adaptation of large language models" 是一种针对大型语言模型进行低秩适应的技术。大型语言模型通常具有数十亿个参数，这使得它们在计算和存储方面非常昂贵。低秩适应的目标是通过将语言模型的参数矩阵分解为低秩近似，来减少模型的复杂度和计算资源的需求。
        
        低秩适应的方法可以通过使用矩阵分解技术，如奇异值分解（Singular Value Decomposition，SVD）或特征值分解（Eigenvalue Decomposition），将语言模型的参数矩阵分解为较低秩的近似矩阵。通过这种方式，可以减少模型的参数量和计算复杂度，同时保留模型的关键特征和性能。
        
        低秩适应的技术可以用于加速大型语言模型的推理过程，减少模型的存储需求，并提高在资源受限环境下的模型效率。它是在大型语言模型优化和压缩领域的一个重要研究方向。
        
        </aside>
        
    - 1.2 LoRA 的思路是什么？
        
        <aside>
        💡
        
        LoRA（Low-Rank Adaptation）是一种用于大规模语言模型的低秩适应方法，旨在减少模型的计算和存储开销。它的核心思想是通过对模型参数矩阵进行低秩分解，以达到降低模型复杂度和提高效率的目的。
        
        具体而言，LoRA的思路可以分为以下几个步骤：
        
        1. 原始模型：首先，我们有一个大规模的语言模型，其参数矩阵往往非常庞大，包含数十亿个参数。
        2. 参数矩阵分解：LoRA通过对模型参数矩阵进行低秩分解，将其分解为两个或多个较小的矩阵的乘积。常用的矩阵分解方法包括奇异值分解（SVD）和特征值分解（Eigenvalue Decomposition）等。
        3. 低秩适应：在参数矩阵分解之后，我们可以选择保留较低秩的近似矩阵，而舍弃一些对模型性能影响较小的细微变化。这样可以减少模型的参数量和计算复杂度，同时保留模型的关键特征和性能。
        4. 重构模型：使用低秩适应后的近似矩阵重新构建语言模型，该模型具有较低的参数量和计算需求，但仍能保持相对较高的性能。
        
        通过LoRA的低秩适应方法，我们可以在不显著损失模型性能的情况下，降低大型语言模型的复杂度和资源需求。这对于在计算资源受限的环境下部署和使用语言模型非常有帮助。
        
        </aside>
        
    - 1.3 LoRA 的特点是什么？
        
        <aside>
        💡
        
        LoRA（Low-Rank Adaptation）具有以下几个特点：
        
        1. 低秩适应：LoRA通过对大型语言模型的参数矩阵进行低秩分解，将其分解为较小的矩阵的乘积。这样可以减少模型的参数量和计算复杂度，提高模型的效率和速度。
        2. 保持关键特征：虽然低秩适应会舍弃一些对模型性能影响较小的细节，但它会尽量保留模型的关键特征。通过选择合适的低秩近似矩阵，可以最大限度地保持模型的性能。
        3. 减少存储需求：低秩适应可以显著减少大型语言模型的参数量，从而降低模型的存储需求。这对于在资源受限的设备上使用语言模型非常有益。
        4. 加速推理过程：由于低秩适应减少了模型的计算复杂度，因此可以加速模型的推理过程。这对于实时应用和大规模部署非常重要。
        5. 可扩展性：LoRA的低秩适应方法可以应用于各种大型语言模型，包括预训练的Transformer模型等。它是一种通用的技术，可以适应不同的模型架构和任务。
        
        总之，LoRA通过低秩适应的方法，可以在减少存储需求和加速推理过程的同时，保持模型的关键特征和性能。这使得它成为在资源受限环境下使用大型语言模型的有效策略。
        
        </aside>
        
- 二、QLoRA篇
    - 2.1 QLoRA 的思路是怎么样的？
        
        <aside>
        💡
        
        QLoRA（Quantized Low-Rank Adaptation）是一种结合了量化和低秩适应的方法，用于进一步减少大规模语言模型的计算和存储开销。它的思路可以概括如下：
        
        1. 量化参数：首先，对大规模语言模型的参数进行量化。量化是一种将浮点数参数转换为固定位数的整数或更简单表示的方法。通过减少参数位数，可以显著减少模型的存储需求和计算复杂度。
        2. 参数矩阵分解：在量化参数之后，QLoRA使用低秩分解的方法对量化参数矩阵进行分解。低秩分解将参数矩阵分解为较小的矩阵的乘积，从而进一步减少模型的参数量和计算复杂度。
        3. 低秩适应：在参数矩阵分解之后，选择保留较低秩的近似矩阵，并舍弃一些对模型性能影响较小的细节。这样可以进一步减少模型的计算需求，同时保持模型的关键特征和性能。
        4. 重构模型：使用低秩适应后的近似矩阵和量化参数重新构建语言模型。这样得到的模型既具有较低的参数量和计算需求，又能保持相对较高的性能。
        
        通过结合量化和低秩适应的思路，QLoRA能够进一步减少大型语言模型的计算和存储开销。它在资源受限的环境下，尤其是移动设备等场景中，具有重要的应用价值。
        
        </aside>
        
    - 2.2 QLoRA 的特点是什么？
        
        <aside>
        💡
        
        QLoRA（Quantized Low-Rank Adaptation）具有以下几个特点：
        
        1. 量化降低存储需求：通过将参数进行量化，将浮点数参数转换为固定位数的整数或更简单的表示，从而显著减少模型的存储需求。这对于在资源受限的设备上使用大型语言模型非常有益。
        2. 低秩适应减少计算复杂度：通过低秩适应的方法，将量化参数矩阵分解为较小的矩阵的乘积，进一步减少模型的参数量和计算复杂度。这可以加速模型的推理过程，提高模型的效率。
        3. 保持关键特征和性能：虽然量化和低秩适应会舍弃一些对模型性能影响较小的细节，但它们会尽量保留模型的关键特征和性能。通过选择合适的量化位数和低秩近似矩阵，可以最大限度地保持模型的性能。
        4. 可扩展性和通用性：QLoRA的量化和低秩适应方法可以应用于各种大型语言模型，包括预训练的Transformer模型等。它是一种通用的技术，可以适应不同的模型架构和任务。
        5. 综合优化：QLoRA综合考虑了量化和低秩适应的优势，通过量化降低存储需求，再通过低秩适应减少计算复杂度，从而实现了更高效的模型。这使得QLoRA成为在资源受限环境下使用大型语言模型的有效策略。
        
        总之，QLoRA通过量化和低秩适应的方法，可以在减少存储需求和计算复杂度的同时，保持模型的关键特征和性能。它具有高效、通用和可扩展的特点，适用于各种大型语言模型的优化。
        
        </aside>
        
- 三、AdaLoRA篇
    - 3.1 AdaLoRA 的思路是怎么样的？
        
        <aside>
        💡
        
        AdaLoRA（Adaptive Low-Rank Adaptation）是一种自适应的低秩适应方法，用于进一步减少大规模语言模型的计算和存储开销。它的思路可以概括如下：
        
        1. 初始低秩适应：首先，对大规模语言模型的参数进行低秩适应。低秩适应是一种将参数矩阵分解为较小的矩阵的乘积的方法，从而减少模型的参数量和计算复杂度。初始低秩适应的目的是在不损失太多性能的情况下，尽可能地减少模型的计算需求。
        2. 评估性能和复杂度：在进行初始低秩适应之后，评估模型的性能和计算复杂度。性能可以通过模型在验证集上的准确率等指标来衡量，而计算复杂度可以通过模型的计算量来衡量。
        3. 自适应调整：根据评估的结果，如果模型的性能满足要求，那么适应低秩矩阵可以作为最终模型的参数。如果模型的性能不满足要求，那么可以考虑增加低秩适应的程度，即进一步减少参数量和计算复杂度。这个过程可以通过增加低秩适应的迭代次数或增加低秩矩阵的秩来实现。
        4. 重构模型：使用自适应调整后的低秩矩阵重新构建语言模型。这样得到的模型既具有较低的参数量和计算需求，又能保持相对较高的性能。
        
        通过自适应的低秩适应方法，AdaLoRA能够根据模型的性能和计算需求进行灵活调整，从而进一步减少大型语言模型的计算和存储开销。它可以根据具体任务和资源限制，自动找到一个平衡点，使模型在性能和效率之间达到最佳的平衡。
        
        </aside>
        
- 四、LoRA权重是否可以合入原模型？
    
    <aside>
    💡
    
    是的，LoRA权重可以合并到原模型中。在使用LoRA进行低秩适应时，原始模型的参数矩阵会被分解为较小的矩阵的乘积。这些较小的矩阵可以表示为低秩矩阵的形式，其中包含了原始模型的权重信息。
    
    合并LoRA权重到原模型的过程通常涉及将低秩矩阵重新组合成原始模型的参数矩阵。这可以通过矩阵乘法等操作来实现。合并后的模型将包含原始模型的权重信息，同时也融入了低秩适应的优化，从而在减少计算和存储开销的同时保持模型性能。
    
    需要注意的是，合并LoRA权重到原模型时，可能会有一些微小的性能损失。这是因为低秩适应过程中对参数进行了量化和近似处理，可能会损失一些细节信息。然而，通过合适的低秩适应方法和参数设置，可以最小化这种性能损失，同时获得较高的效率和较低的资源开销。
    
    </aside>
    
- 五、ChatGLM-6B LoRA后的权重多大？
- 六、LoRA 微调优点是什么？
    
    <aside>
    💡
    
    LoRA微调具有以下几个优点：
    
    1. 保留原模型的知识：LoRA微调是在原模型的基础上进行的，因此可以保留原模型所学到的知识和表示能力。这意味着LoRA微调的模型可以继承原模型在大规模数据上训练得到的特征提取能力和语言模型知识，从而在微调任务上表现更好。
    2. 减少微调时间和资源开销：由于LoRA已经对原模型进行了低秩适应，减少了参数量和计算复杂度，因此LoRA微调所需的时间和资源开销相对较小。这对于大规模语言模型的微调任务来说是非常有益的，可以加快模型的训练和推理速度，降低资源消耗。
    3. 提高模型泛化能力：LoRA微调通过低秩适应，对原模型进行了一定程度的正则化。这种正则化可以帮助模型更好地泛化到新的任务和数据上，减少过拟合的风险。LoRA微调的模型通常具有更好的泛化能力，能够适应不同领域和任务的需求。
    4. 可扩展性和灵活性：LoRA微调方法的设计可以根据具体任务和资源限制进行调整和优化。可以通过调整低秩适应的程度、迭代次数和参数设置等来平衡性能和效率。这种灵活性使得LoRA微调适用于不同规模和需求的语言模型，具有较高的可扩展性。
    
    综上所述，LoRA微调具有保留知识、减少资源开销、提高泛化能力和灵活性等优点，使得它成为大规模语言模型微调的一种有效方法。
    
    </aside>
    
- 七、LoRA微调方法为啥能加速训练？
    
    <aside>
    💡
    
    LoRA微调方法能够加速训练的原因主要有以下几点：
    
    1. 低秩适应减少了参数量：LoRA微调使用低秩适应方法对原模型的参数进行分解，将原始的参数矩阵分解为较小的矩阵的乘积形式。这样可以大幅度减少参数量，从而减少了模型的存储需求和计算复杂度。减少的参数量意味着更少的内存占用和更快的计算速度，从而加速了训练过程。
    2. 降低了计算复杂度：由于LoRA微调减少了参数量，每个参数的计算量也相应减少。在训练过程中，计算参数更新和梯度传播的时间会显著减少，从而加速了训练过程。特别是在大规模语言模型中，参数量巨大，计算复杂度很高，LoRA微调可以显著减少计算开销，提高训练效率。
    3. 加速收敛速度：LoRA微调通过低秩适应对原模型进行了正则化，使得模型更容易收敛到较好的解。低秩适应过程中的正则化可以帮助模型更好地利用数据进行训练，减少过拟合的风险。这样可以加快模型的收敛速度，从而加速训练过程。
    4. 提高了计算效率：LoRA微调方法通过低秩适应减少了模型的参数量和计算复杂度，从而提高了计算效率。这意味着在相同的计算资源下，LoRA微调可以处理更大规模的数据和更复杂的任务。同时，也可以利用较少的计算资源来训练模型，从而减少了时间和成本。
    
    综上所述，LoRA微调方法通过减少参数量、降低计算复杂度、加速收敛速度和提高计算效率等方式，能够显著加速训练过程，特别适用于大规模语言模型的微调任务。
    
    </aside>
    
- 八、如何在已有LoRA模型上继续训练？
    
    <aside>
    💡
    
    在已有LoRA模型上继续训练可以按照以下步骤进行：
    
    1. 加载已有的LoRA模型：首先，需要加载已经训练好的LoRA模型，包括原始模型的参数和低秩适应所得到的参数。可以使用相应的深度学习框架提供的函数或方法来加载模型。
    2. 准备微调数据集：根据需要进行微调的任务，准备相应的微调数据集。这些数据集可以是新的标注数据，也可以是从原始训练数据中选择的子集。确保微调数据集与原始训练数据集具有一定的相似性，以便模型能够更好地泛化到新的任务上。
    3. 设置微调参数：根据任务需求，设置微调的超参数，包括学习率、批大小、训练轮数等。这些参数可以根据经验或者通过实验进行调整。注意，由于LoRA已经对原模型进行了低秩适应，可能需要调整学习率等参数来适应新的微调任务。
    4. 定义微调目标函数：根据任务类型，定义微调的目标函数。这可以是分类任务的交叉熵损失函数，回归任务的均方误差损失函数等。根据具体任务需求，可以选择合适的损失函数。
    5. 进行微调训练：使用微调数据集和定义的目标函数，对已有的LoRA模型进行微调训练。根据设定的超参数进行迭代训练，通过反向传播和优化算法更新模型参数。可以使用批量梯度下降、随机梯度下降等优化算法来进行模型参数的更新。
    6. 评估和调整：在微调训练过程中，定期评估模型在验证集上的性能。根据评估结果，可以调整超参数、微调数据集等，以进一步优化模型的性能。
    7. 保存微调模型：在微调训练完成后，保存微调得到的模型参数。这样就可以在后续的推理任务中使用微调后的模型。
    
    需要注意的是，在进行微调训练时，需要根据具体任务和数据集的特点进行调整和优化。可能需要尝试不同的超参数设置、微调数据集的选择等，以获得更好的微调效果。
    
    </aside>
